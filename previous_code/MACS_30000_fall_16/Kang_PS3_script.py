'''
------------------------------------------------------------------------
This is Bobae's PS3:
The current script contains the codes for exercises 1, 2 and 3.
All plots generated by this script will be saved in 'images' folder.
------------------------------------------------------------------------
'''
# import all packages
import pandas as pd
import numpy as np
from pandas import Series, DataFrame
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import datetime
from datetime import timedelta
import os

# set the directory for saving images
cur_path = os.path.split(os.path.abspath(__file__))[0]
output_fldr = 'images'
output_dir = os.path.join(cur_path, output_fldr)
if not os.access(output_dir, os.F_OK):
    os.makedirs(output_dir)
'''
------------------------------------------------------------------------
Exercise 1. A lifetime of temperatures
The following code reads the data on max and min temparature for the
lifetime of an individual named Ricardo, from 1975-01-22 to 2016-10-31.
It visualizes the temperature data in a scatterplot, in which the x-axis
indicates dates starting from September 21 of any year and the y-axis
indicates the temperature in fahrenheit. The temperature data for the time
Ricardo lived in Chicago are in maroon color. The plot also highlights
the temperature for two significant life events.
------------------------------------------------------------------------
'''
# reading in temperature data
city = ['Indianapolis', 'Pittsburgh', 'Maimi', 'Washington DC', 'Chicago']
# temparature data for Indianapolis, from 1975-01-22 to 1980-07-31
indiTemp = DataFrame(pd.read_csv('indianapolis.csv'))
indiTemp = indiTemp[indiTemp['STATION'] == 'GHCND:USW00093819']
indiTemp['LOCATION'] = city[0]
indiTemp = indiTemp[['DATE', 'LOCATION', 'TMAX', 'TMIN']]
#print(indiTemp)

# temperature data for Pittsburgh, from 1980-08-01 to 1993-08-16
pittsTemp = DataFrame(pd.read_csv('pittsburgh.csv'))
pittsTemp = pittsTemp[pittsTemp['STATION'] == 'GHCND:USW00094823']
pittsTemp['LOCATION'] = city[1]
pittsTemp = pittsTemp[['DATE', 'LOCATION', 'TMAX', 'TMIN']]
#print(pittsTemp)

# temperature data for Miami, from 1993-08-17 to 1998-05-04
miamiTemp = DataFrame(pd.read_csv('miami.csv'))
miamiTemp = miamiTemp[miamiTemp['STATION'] == 'GHCND:USW00012839']
miamiTemp['LOCATION'] = city[2]
miamiTemp = miamiTemp[['DATE', 'LOCATION', 'TMAX', 'TMIN']]
#print(miamiTemp)

# temperature data for Washington D.C., from 1998-05-05 to 2006-06-02
dcTemp = DataFrame(pd.read_csv('washingtondc.csv'))
dcTemp = dcTemp[dcTemp['STATION'] == 'GHCND:USW00093738']
dcTemp['LOCATION'] = city[3]
dcTemp = dcTemp[['DATE', 'LOCATION', 'TMAX', 'TMIN']]
#print(dcTemp)

# temperature data for Chicago, from 2006-06-03 to 2016-10-31
chiTemp = DataFrame(pd.read_csv('chicago.csv'))
chiTemp = chiTemp[chiTemp['STATION'] == 'GHCND:USW00004838']
chiTemp['LOCATION'] = city[4]
chiTemp = chiTemp[['DATE', 'LOCATION', 'TMAX', 'TMIN']]
#print(chiTemp)

# joining all temperature data into one data frame
lifeTemp = indiTemp.append(pittsTemp, ignore_index = True).append(miamiTemp, ignore_index = True).append(dcTemp, ignore_index = True).append(chiTemp, ignore_index = True)
# convert values in the 'DATE' columne into the datetime format
lifeTemp['DATE'] = lifeTemp['DATE'].astype('str')
lifeTemp['DATE'] = pd.to_datetime(lifeTemp['DATE'], format='%Y%m%d')

# create a 'KEY' columne
lifeTemp['KEY'] = '2016' + '-' + lifeTemp['DATE'].apply(lambda x: x.month).astype(str) + '-' + lifeTemp['DATE'].apply(lambda x: x.day).astype(str)
lifeTemp['KEY'] = pd.to_datetime(lifeTemp['KEY'])
# make the 'KEY' values into index values, by which September 21 has the value of 0
lifeTemp['KEY'] = lifeTemp['KEY'].apply(lambda x: x - pd.to_datetime('2016-09-21'))
def keyindex(x):
    if x < timedelta(days = 0):
        x = timedelta(days = 366) + x
    return x.days
lifeTemp['KEY'] = lifeTemp['KEY'].apply(keyindex)

# prepare the objects for plotting
# temperature points for all days
key = lifeTemp['KEY']
tmax = lifeTemp['TMAX']
tmin = lifeTemp['TMIN']
# temperature points for all days before Chicago
key_nochi = lifeTemp[lifeTemp['LOCATION'] != 'Chicago']['KEY']
tmax_nochi = lifeTemp[lifeTemp['LOCATION'] != 'Chicago']['TMAX']
tmin_nochi = lifeTemp[lifeTemp['LOCATION'] != 'Chicago']['TMIN']
# temperature points for days in Chicago
key_chi = lifeTemp[lifeTemp['LOCATION'] == 'Chicago']['KEY']
tmax_chi = lifeTemp[lifeTemp['LOCATION'] == 'Chicago']['TMAX']
tmin_chi = lifeTemp[lifeTemp['LOCATION'] == 'Chicago']['TMIN']
# temperature points for the date of birth
key_born = lifeTemp[lifeTemp['DATE'] == pd.to_datetime('1975-01-22')]['KEY']
tmax_born = lifeTemp[lifeTemp['DATE'] == pd.to_datetime('1975-01-22')]['TMAX']
tmin_born = lifeTemp[lifeTemp['DATE'] == pd.to_datetime('1975-01-22')]['TMIN']
# temperature points for the date of the little league all star regional championship
key_allstar = lifeTemp[lifeTemp['DATE'] == pd.to_datetime('1988-07-14')]['KEY']
tmax_allstar = lifeTemp[lifeTemp['DATE'] == pd.to_datetime('1988-07-14')]['TMAX']
tmin_allstar = lifeTemp[lifeTemp['DATE'] == pd.to_datetime('1988-07-14')]['TMIN']

# visualize
fig, ax = plt.subplots(1, 1)
# temperature points for all days
plt.scatter(key_nochi, tmax_nochi, color = 'black', alpha = 0.9, s = 3) # TMAX before Chicago
plt.scatter(key_nochi, tmin_nochi, color = 'black', alpha = 0.9, s = 3) # TMIN before Chicago
plt.scatter(key_chi, tmax_chi, color = 'maroon', alpha = 0.9, s = 3) # TMAX after Chicago
plt.scatter(key_chi, tmin_chi, color = 'maroon', alpha = 0.9, s = 3) # TMIN after Chicago
# temperature points for life events
plt.scatter(key_born, tmax_born, color = 'yellow', edgecolor = 'black', lw = 3, s = 50)
plt.scatter(key_born, tmin_born, color = 'yellow', edgecolor = 'black', lw = 3, s = 50)
plt.scatter(key_allstar, tmax_allstar, color = 'yellow', edgecolor = 'black', lw = 3, s = 50)
plt.scatter(key_allstar, tmin_allstar, color = 'yellow', edgecolor = 'black', lw = 3, s = 50)
# title and labels
plt.title('A lifetime of temperatures')
plt.xlabel('Season')
plt.ylabel('Temperature (in fahrenheit)')
# limit and ticks for the x-axis
plt.xlim((0-10,366+10))
ax.set_xticks([366/8, 366*3/8, 366*5/8, 366*7/8])
ax.set_xticklabels(['FALL', 'WINTER', 'SPRING', 'SUMMER'])
# marking the two life events
ax.annotate('Born', xy=(key_born, tmax_born+3), xytext=(key_born, tmax_born+60),
            arrowprops=dict(facecolor='yellow', width = 3, shrink=0.03),
            )
ax.annotate('Little League', xy=(key_allstar, tmin_allstar-3),
            xytext=(key_allstar, tmin_allstar-50),
            arrowprops=dict(facecolor='yellow', width = 3, shrink=0.03),
            )
# save the plot
output_path_1 = os.path.join(output_dir, 'fig_1')
plt.savefig(output_path_1, bbox_inches = 'tight')
# show the plot
plt.show()
plt.close()

'''
------------------------------------------------------------------------
Exercise 2. 3D histogram
The following code reads in the data on the cholesterol and trigliceride
measurements from the blood of 371 individuals, 51 of which had no history
f current evidence of heart disease and 320 of which have evidence of
heart disease. Then it creates a 2D histogram showing the distribution
of cholesterol measurement among heart diesease group and a 3D histogram
showing the distributions of both cholesterol and trigliceride measurements
among the same group.
------------------------------------------------------------------------
'''
# read in the data
lipids = DataFrame(pd.read_csv('lipids.csv', skiprows = [0, 1, 2]))
diseased = lipids[lipids['diseased'] == 1]

# 2.(a)
# create the 2D histogram
cholesterol = diseased['chol']
weights = (1/len(cholesterol) * np.ones_like(cholesterol))
n, bin_cuts, patches = plt.hist(cholesterol, 25, weights = weights)
plt.xticks(np.round_(bin_cuts, 1), rotation = 45)
plt.title('Histogram of the cholesterol level among the diseased')
plt.xlabel('Cholesterol level (mg/dl)')
plt.ylabel('Percent of observations')
# save the histogram
output_path_2a = os.path.join(output_dir, 'fig_2a')
plt.savefig(output_path_2a, bbox_inches = 'tight')
# show the histogram
plt.show()
plt.close()

# The answer to the question 2.(a)
# The midpoint of the bin with the highest frequency is 236.05.

# 2.(b)
# create the 3D histogram
# prepare the data to be plotted
cholesterol = diseased['chol']
triglicerides = diseased['trig']
# create the hisgram
fig = plt.figure()
ax = fig.add_subplot(111, projection ='3d')
bin_num = int(25)
hist, xedges, yedges = np.histogram2d(cholesterol, triglicerides, bins=bin_num)
hist = hist / hist.sum()
x_midp = xedges[:-1] + 0.5 * (xedges[1] - xedges[0])
y_midp = yedges[:-1] + 0.5 * (yedges[1] - yedges[0])
elements = (len(xedges) - 1) * (len(yedges) - 1)
ypos, xpos = np.meshgrid(y_midp, x_midp)
xpos = xpos.flatten()
ypos = ypos.flatten()
zpos = np.zeros(elements)
dx = (xedges[1] - xedges[0]) * np.ones_like(bin_num)
dy = (yedges[1] - yedges[0]) * np.ones_like(bin_num)
dz = hist.flatten()
ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color='g', zsort='average')
ax.set_xlabel('Cholesterol level (mg/dl)')
ax.set_ylabel('Triglicerides level (mg/dl)')
ax.set_zlabel('Percent of obs.')
plt.title('Histogram by cholesterol and triglicerides levels among the diseased')
# save the histogram
output_path_2b = os.path.join(output_dir, 'fig_2b')
plt.savefig(output_path_2b, bbox_inches = 'tight')
# show the histogram
plt.show()
plt.close()

# The answer to the question 2.(b)
# The levels of cholesterol and triglicerides are largely not correlated to each other.

# 2.(c)
# The answer to the question
# According to the 3D plot, the groups with the highest risk for heart disease are those with
# the triglicerides level of little less than 200 and the the cholesterol levels of both around 180 and 240.

'''
------------------------------------------------------------------------
Exercise 3.
The following codes read in the data on the number of jobs in the US
and create a plot to compare the impact of 14 different recessions,
from the Great Depression in 1929 to the Great Recession in 2008,
on the number of jobs in the US economy.
------------------------------------------------------------------------
'''
# read in the data
payems = DataFrame(pd.read_csv('payems.csv', skiprows = [0,1,2,3,4]))
payems['date'] = pd.to_datetime(payems['date'])
peaks = Series([19290801, 19370501, 19450201, 19481101, 19530701, 19570801, 19600401, 19691201, 19731101, 19800101, 19810701, 19900701, 20010301, 20071201])
peaks = pd.to_datetime(peaks.astype(str))

# fix the errors for the year
def fixyear(x):
    if x > pd.to_datetime('20200101'):
        x = x.replace(year = x.year - 100)
    return x
payems['date'] = payems['date'].apply(fixyear)
#print(payems)

# create a data frame for each recession
rec0 = payems[0:8] # 1929 Great Depression
rec0['percent'] = rec0['payems'] / rec0['payems'][0]
rec0['time'] = [-1, 11, 23, 35, 47, 59, 71, 83]

after1 = peaks[1].replace(year = peaks[1].year + 7)
after_ix1 = payems[payems['date'] == after1].index[0]
rec1 = payems[7:after_ix1+1]
rec1['percent'] = rec1['payems'] / rec1['payems'][8]
a = Series([-10, 2, 14])
b = Series(range(20,85))
rec1['time'] = a.append(b).tolist() # 1937 recession

def rec_cycle(rec): # function to create the later recessions
    before = rec.replace(year = rec.year - 1)
    after = rec.replace(year = rec.year + 7)
    peak_ix = payems[payems['date'] == rec].index[0]
    before_ix = payems[payems['date'] == before].index[0]
    after_ix = payems[payems['date'] == after].index[0]
    cycle = payems[before_ix:after_ix+1]
    cycle['percent'] = cycle['payems'] / cycle['payems'][peak_ix]
    cycle['time'] = cycle.index - cycle.index[12]
    return cycle

rec2 = rec_cycle(peaks[2]) # 1945 recession
rec3 = rec_cycle(peaks[3]) # 1948 recession
rec4 = rec_cycle(peaks[4]) # 1953 recession
rec5 = rec_cycle(peaks[5]) # 1957 recession
rec6 = rec_cycle(peaks[6]) # 1960 recession
rec7 = rec_cycle(peaks[7]) # 1969 recession
rec8 = rec_cycle(peaks[8]) # 1973 recession
rec9 = rec_cycle(peaks[9]) # 1980 recession
rec10 = rec_cycle(peaks[10]) # 1981 recession
rec11 = rec_cycle(peaks[11]) # 1990 recession
rec12 = rec_cycle(peaks[12]) # 2001 recession
rec13 = rec_cycle(peaks[13]) # 2007 Great Recession
rec = Series([rec0, rec1, rec2, rec3, rec4, rec5, rec6, rec7, rec8, rec9, rec10, rec11, rec12, rec13])

# create a plot
fig, ax = plt.subplots(1, 1)
lines = Series(['-', '-.', ':', '--', '-', '-.', ':', '--', '-', '-.', ':', '--', '-', '-.'])
plt.plot(rec[0]['time'], rec[0]['percent'], label = peaks[0].date(), color = 'k', linewidth = 3) # Great Depression
for i in range(1, 13): # all the others
    plt.plot(rec[i]['time'], rec[i]['percent'], label = peaks[i].date(), linestyle = lines[i])
plt.plot(rec[13]['time'], rec[13]['percent'], label = peaks[13].date(), color = 'r', linewidth = 3) # Great Recssion
# vertical and horizontal lines
plt.axvline(x=0, ymin=-0.7, ymax = 1.4, linewidth=1.5, color='.25', linestyle = '--')
plt.axhline(y=1, xmin=-12, xmax=84, linewidth=1.5, color = '.25', linestyle = '--')
# ticks for the x-axis
ax.set_xticks([-12, 0, 12, 24, 36, 48, 60, 72, 84])
ax.set_xticklabels(['-1yr', 'peak', '+1yr', '+2yr', '+3yr', '+4yr', '+5yr', '+6yr', '+7yr'])
# labels
plt.title('Comparing recessions')
plt.xlabel('Time from peak')
plt.ylabel('Jobs/peak')
#legend and grid
plt.legend(loc='upper left', prop={'size':8}, bbox_to_anchor=(1,1))
plt.grid(b = True, which='major', color = '0.65', linestyle = '-')
# save the plot
output_path_3 = os.path.join(output_dir, 'fig_3')
plt.savefig(output_path_3, bbox_inches = 'tight')
# show plot
plt.show()
plt.close()
